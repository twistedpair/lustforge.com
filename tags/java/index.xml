<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on lust.dev</title><link>https://lust.dev/tags/java/</link><description>Recent content in Java on lust.dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Joe Lust</copyright><lastBuildDate>Sat, 08 Feb 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://lust.dev/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Don’t call non-final methods from your constructor, please.</title><link>https://lust.dev/2014/02/08/dont-call-non-final-methods-from-your-constructor-please/</link><pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate><guid>https://lust.dev/2014/02/08/dont-call-non-final-methods-from-your-constructor-please/</guid><description>I ran into problems with someone doing this recently, so I’ll have to embellish the web a little more. The world must learn.
Why don’t we call non-final methods from constructors? Because it’s bad. Why is it bad? Because OO has an order to the madness and this ain’t the order. Let’s do a quick experiment to find out why.
Here is our parent and child class.
public class FooKlassParent{ static { log(&amp;#34;Parent: Init static block 1&amp;#34;); } public SysWriter w1 = new SysWriter(&amp;#34;Parent: non-static field init&amp;#34;); private static final SysWriter w2 = new SysWriter( &amp;#34;Parent: static field init&amp;#34;); public FooKlassParent() { super(); log(&amp;#34;Parent: Constructor called&amp;#34;); doSomething(); } static { log(&amp;#34;Parent: Init static block 2&amp;#34;); } public void doSomething() { log(&amp;#34;Parent: do something&amp;#34;); } protected static void log(final String msg) { log(msg); } } So many goodies!</description></item><item><title>MyBatis Query Optimization : Dollar Sign be Damned</title><link>https://lust.dev/2014/02/05/mybatis-query-optimization-dollar-sign-be-damned/</link><pubDate>Wed, 05 Feb 2014 00:00:00 +0000</pubDate><guid>https://lust.dev/2014/02/05/mybatis-query-optimization-dollar-sign-be-damned/</guid><description>I discovered a shocking truth today. We use MyBatis on my current project for read only queries. Recently we had a cache populating job that ran rather slowly. We optimized and optimized cleaning up the queries and adjusting the database indexes and statistics tables. Try as we may, the job still required 30+ minutes each day.
Miraculously the job dropped to 3 minutes yesterday. It must be broken! Check the logs!</description></item><item><title>Mockito Fails to Inject Autowired Dependency</title><link>https://lust.dev/2013/08/06/mockito-fails-to-inject-autowired-dependency/</link><pubDate>Tue, 06 Aug 2013 00:00:00 +0000</pubDate><guid>https://lust.dev/2013/08/06/mockito-fails-to-inject-autowired-dependency/</guid><description>If you must test Spring beans and you’ve used @autowired in them, then you’ll need to use Mockito.
EasyMock is easy for easy things, but breaks down in this more complex situation. No worries, just let Mockito inject those DI dependencies for you. Ugh oh… they are not injecting. But you’ve read their docs and they should inject! Sadness.
Let’s set the stage. Enter our sample class stage left.
public final SampleImpl { @autowired private Foo someFoo; private Bar someBar; public SampleImpl(final Bar someBar) { this.</description></item><item><title>Caused by: java.lang.ClassNotFoundException: org.apache.ibatis.mapping.DatabaseIdProvider</title><link>https://lust.dev/2013/07/27/caused-by-java-lang-classnotfoundexception-org-apache-ibatis-mapping-databaseidprovider/</link><pubDate>Sat, 27 Jul 2013 00:00:00 +0000</pubDate><guid>https://lust.dev/2013/07/27/caused-by-java-lang-classnotfoundexception-org-apache-ibatis-mapping-databaseidprovider/</guid><description>Perhaps you’ve had this trace recently while trying to get myBatis working on Spring:
Caused by: java.lang.ClassNotFoundException: org.apache.ibatis.mapping.DatabaseIdProvider at java.net.URLClassLoader$1.run(URLClassLoader.java:217) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:205) at java.lang.ClassLoader.loadClass(ClassLoader.java:321) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294) at java.lang.ClassLoader.loadClass(ClassLoader.java:266) ... 57 more It is the bane of open source. You can’t always depend on quality releases. Don’t worry, you followed the tutorial correctly. Let’s take a look at the package’s history in Maven Central.
Maybe something is not quite right with 1.</description></item><item><title>GWT JSNI Variables – An Exhaustive List</title><link>https://lust.dev/2012/11/11/gwt-jsni-variables-an-exhaustive-list/</link><pubDate>Sun, 11 Nov 2012 00:00:00 +0000</pubDate><guid>https://lust.dev/2012/11/11/gwt-jsni-variables-an-exhaustive-list/</guid><description>As anyone using the Google Web Toolkit JSNI knows, there are certain reserved variables, or “dollar words,” exposed by the GWT runtime. While you may be familiar with $wnd and $doc, there are more undocumented words. See the exhaustive (as of GWT 2.5.0) list below taken from source.
$wnd Reference to the root browser window GWT widgets are being rendered to. Note that when called from the iframe linker, GWT code runs in an iframe, not the root browser window, so calling window will reference the wrong window.</description></item><item><title>Spring’s RememberMe and BadCredentialsException</title><link>https://lust.dev/2012/10/17/springs-rememberme-and-badcredentialsexception/</link><pubDate>Wed, 17 Oct 2012 00:00:00 +0000</pubDate><guid>https://lust.dev/2012/10/17/springs-rememberme-and-badcredentialsexception/</guid><description>Spring is pretty swell, but the documentation is never what you need. It would be like reading an anatomy book about every organ in the body, but never being shown a picture of all of them together, and then trying to conduct a surgery.
I was assembling Spring Security for a rewrite of RunPartner.com and read the RememberMe chapter of Spring Security.
&amp;lt;http&amp;gt; ... &amp;lt;remember-me key=&amp;#34;myAppKey&amp;#34;/&amp;gt; &amp;lt;/http&amp;gt; Since I needed a database backed implementation, I liked the next example.</description></item><item><title>Comparing BigDecimals with Round and SetScale</title><link>https://lust.dev/2011/07/14/comparing-bigdecimals-with-round-and-setscale/</link><pubDate>Thu, 14 Jul 2011 00:00:00 +0000</pubDate><guid>https://lust.dev/2011/07/14/comparing-bigdecimals-with-round-and-setscale/</guid><description>In Java financial programming, you need the precision BigDecimals afford. However, due to the great precision of this value, comparisons are very error prone. For example:
0.000000000000000000000000000000001 != 0.0 For most cases, we want to round when the calculations are complete to the desired precision, rather than during intermediate steps.
DON&amp;rsquo;T USE round() as it sets the number of significant digits, not the number of decimals. It will lead to odd behavior if you do, as shown below.</description></item></channel></rss>