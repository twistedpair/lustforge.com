<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IBatis on lust.dev</title><link>https://lust.dev/tags/ibatis/</link><description>Recent content in IBatis on lust.dev</description><generator>Hugo</generator><language>en-us</language><copyright>Joe Lust</copyright><lastBuildDate>Sun, 12 Oct 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://lust.dev/tags/ibatis/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Immutable Objects with MyBatis</title><link>https://lust.dev/2014/10/12/using-immutable-objects-with-mybatis/</link><pubDate>Sun, 12 Oct 2014 00:00:00 +0000</pubDate><guid>https://lust.dev/2014/10/12/using-immutable-objects-with-mybatis/</guid><description>&lt;h3 id="immutable-is-beautiful">Immutable is Beautiful&lt;/h3>
&lt;p>I’m a fan of immutable objects. We all know the benefits; simple, no mutators, thread safe, cache word optimizable. However, I see far too many MyBatis (and iBatis) developers adding no arg constructors to their POJO’s simply so that MyBatis can reflect and set all of the values into the field setters. I’ll ask “&lt;em>why does this POJO need to be mutated&lt;/em>” and they quip that it doesn’t, but these setters and protected no-arg constructors are needed by MyBatis. This violates my principle that you make your library work with your code, not the other way around.&lt;/p></description></item></channel></rss>